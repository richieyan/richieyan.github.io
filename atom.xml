<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>b.mithril</title>
  
  
  <link href="http://b.mithril.cool/atom.xml" rel="self"/>
  
  <link href="http://b.mithril.cool/"/>
  <updated>2020-10-17T06:00:49.136Z</updated>
  <id>http://b.mithril.cool/</id>
  
  <author>
    <name>mithril</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 性能分析之 Arthas 火焰图</title>
    <link href="http://b.mithril.cool/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    <id>http://b.mithril.cool/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/</id>
    <published>2020-10-16T13:01:37.000Z</published>
    <updated>2020-10-17T06:00:49.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要做性能分析"><a href="#为什么要做性能分析" class="headerlink" title="为什么要做性能分析"></a>为什么要做性能分析</h2><p>很多场景的 Java 应用中 IT 成本中 CPU 成本常常是成本的大头，如果能够有效优化 Java 应用的 CPU 占用，可以较好降低成本，提升程序响应速度。<br>Java 性能分析分为两部分</p><ul><li><strong>业务性能：某些的业务代码引起的性能瓶颈</strong></li><li>JVM 性能调优：JVM 设置存在优化</li></ul><p>本文主要关注业务代码的热点问题。</p><h2 id="Arthas-是什么？"><a href="#Arthas-是什么？" class="headerlink" title="Arthas 是什么？"></a>Arthas 是什么？</h2><blockquote><p><em>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</em></p></blockquote><blockquote><p><a href="https://arthas.aliyun.com/doc/">官方文档</a>  <a href="https://github.com/alibaba/arthas">源码地址</a></p></blockquote><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li><strong>怎么快速定位应用的热点，生成火焰图？</strong></li></ul><p>本文主要介绍如何利用 <code>profiler</code> 命令来定位应用热点，从而优化应用的性能。</p><h2 id="为什么选择-Arthas-来做火焰图？"><a href="#为什么选择-Arthas-来做火焰图？" class="headerlink" title="为什么选择 Arthas 来做火焰图？"></a>为什么选择 Arthas 来做火焰图？</h2><p>Arthas 无需代理模式启动应用，通过 Attach 进程方式即可实现 Java 应用的诊断与性能分析。<br>详细可以参考：<a href="https://zhuanlan.zhihu.com/p/115127052">Arthas 原理分析</a></p><p>Java 火焰图在 Netflix 的加持下，逐渐成熟， <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profile</a> 出现后进一步降低了对 Java 火焰图的分析步骤。</p><p>Arthas 在 3.1.5 版本开始支持 <code>async-profile</code>, 无需配置，快速实现 profile 分析。</p><h2 id="使用-Arthas-生成火焰图"><a href="#使用-Arthas-生成火焰图" class="headerlink" title="使用 Arthas 生成火焰图"></a>使用 Arthas 生成火焰图</h2><h3 id="安装和启动-Arthas"><a href="#安装和启动-Arthas" class="headerlink" title="安装和启动 Arthas"></a>安装和启动 Arthas</h3><p><code>arthas</code> 是一个 <code>jar</code> 包，下载后直接运行即可，然后执行相应命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><h3 id="创建火焰图"><a href="#创建火焰图" class="headerlink" title="创建火焰图"></a>创建火焰图</h3><h4 id="启动-arthas-后，attach-到实际的进程"><a href="#启动-arthas-后，attach-到实际的进程" class="headerlink" title="启动 arthas 后，attach 到实际的进程"></a>启动 arthas 后，attach 到实际的进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  arthas java -jar arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: 3.4.3</span><br><span class="line">[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.</span><br><span class="line">*  [1]: 4541</span><br><span class="line">1</span><br><span class="line">[INFO] arthas home: /Users/yzz/.arthas/lib/3.4.3/arthas</span><br><span class="line">[INFO] Try to attach process 4541</span><br><span class="line">[INFO] Attach process 4541 success.</span><br><span class="line">[INFO] arthas-client connect 127.0.0.1 3658</span><br><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.</span><br><span class="line"> /  O  \ |  .--. <span class="string">&#x27;&#x27;</span>--.  .--<span class="string">&#x27;|  &#x27;</span>--<span class="string">&#x27;  | /  O  \ &#x27;</span>   .-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">|  .-.  ||  &#x27;</span>--<span class="string">&#x27;.&#x27;</span>   |  |   |  .--.  ||  .-.  |`.  `-.</span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">`--&#x27;</span> `--<span class="string">&#x27;`--&#x27;</span> <span class="string">&#x27;--&#x27;</span>   `--<span class="string">&#x27;   `--&#x27;</span>  `--<span class="string">&#x27;`--&#x27;</span> `--<span class="string">&#x27;`-----&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wiki      https://arthas.aliyun.com/doc</span><br><span class="line">tutorials https://arthas.aliyun.com/doc/arthas-tutorials.html</span><br><span class="line">version   3.4.3</span><br><span class="line">pid       4541</span><br><span class="line">time      2020-10-17 13:14:03</span><br><span class="line"></span><br><span class="line">[arthas@4541]$</span><br></pre></td></tr></table></figure><p><em>注意： 输入前面的序号 <code>1</code> 不是 <code>724</code></em></p><h4 id="使用-profiler-命令"><a href="#使用-profiler-命令" class="headerlink" title="使用 profiler 命令"></a>使用 <code>profiler</code> 命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">[arthas@4541]$ profiler start</span><br><span class="line">Started [cpu] profiling</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">[arthas@4541]$ profiler status</span><br><span class="line">[cpu] profiling is running <span class="keyword">for</span> 13 seconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">[arthas@4541]$ profiler stop --file /tmp/output.svg</span><br><span class="line">OK</span><br><span class="line">profiler output file: /tmp/output.svg</span><br></pre></td></tr></table></figure><p>本机可以通过 <code>http://localhost:3658/arthas-output/</code> 直接查看结果<br>也可以通过 <code>Chrome</code> 打开 <code>output.svg</code> 文件</p><p><img src="/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/flame-1.jpg" alt="Flame-1"></p><p>点击某个函数调用栈可以看到放大局部的调用栈，最新 <code>3.28%</code> 是 CPU 占比。<br><img src="/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/flame-2.jpg" alt="Flame-2"></p><p>点击 <code>all</code> 返回默认的全局展示。</p><h2 id="看懂火焰图"><a href="#看懂火焰图" class="headerlink" title="看懂火焰图"></a>看懂火焰图</h2><p>Y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>X 轴表示抽样数，如果一个函数在x轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有平顶 (plateaus)，就表示该函数可能存在性能问题。</p><p>颜色没有实际意义，只是随机选取用于栈帧之间相互区分，左右顺序也没有什么含义。</p><p><img src="/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/flame-grahs-how-to-read.webp" alt="Flame Graphs: How to Read"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要做性能分析&quot;&gt;&lt;a href=&quot;#为什么要做性能分析&quot; class=&quot;headerlink&quot; title=&quot;为什么要做性能分析&quot;&gt;&lt;/a&gt;为什么要做性能分析&lt;/h2&gt;&lt;p&gt;很多场景的 Java 应用中 IT 成本中 CPU 成本常常是成本的大头，如果能够有</summary>
      
    
    
    
    
    <category term="Java Performance" scheme="http://b.mithril.cool/tags/Java-Performance/"/>
    
  </entry>
  
  <entry>
    <title>本站 Hexo 搭建历程</title>
    <link href="http://b.mithril.cool/2020/10/09/%E6%9C%AC%E7%AB%99-Hexo-%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"/>
    <id>http://b.mithril.cool/2020/10/09/%E6%9C%AC%E7%AB%99-Hexo-%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</id>
    <published>2020-10-09T03:56:34.000Z</published>
    <updated>2020-10-17T06:02:23.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.im/post/6844904131266609165#heading-18">使用Hexo+GitHubPages搭建个人博客</a></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库分为两个</p><ul><li>github pages 仓库： 用于托管博客</li><li>hexo blog 仓库： 用于管理博客</li></ul><h3 id="环境与插件"><a href="#环境与插件" class="headerlink" title="环境与插件"></a>环境与插件</h3><p>hexo blog 目录下安装 hexo 及插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置使用 taobo 源</span></span><br><span class="line">npm --registry https://registry.npm.taobao.org install</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo-cli</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># plugins</span></span><br><span class="line">npm i hexo-deployer-git --save</span><br><span class="line">npm i hexo-generator-json-content --save</span><br><span class="line">npm i hexo-wordcount --save</span><br><span class="line">npm i hexo-generator-feed --save</span><br><span class="line">npm i hexo-generator-sitemap --save</span><br><span class="line">npm i hexo-generator-baidu-sitemap --save</span><br><span class="line">npm i hexo-renderer-marked --save</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>hexo 常用的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文章</span></span><br><span class="line">hexo new &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成博客</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预览博客</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布博客</span></span><br><span class="line">hexo generate --deploy</span><br><span class="line">hexo deploy --generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布博客简化版</span></span><br><span class="line">hexo g -d</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul><li>在 DNS 设置 <code>CNAME</code></li><li>在 <code>source</code> 创建一个 <code>CNAME</code> 文件, 本站内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.mithril.cool</span><br></pre></td></tr></table></figure></li></ul><h3 id="文章资源"><a href="#文章资源" class="headerlink" title="文章资源"></a>文章资源</h3><p>通过 <code>post_asset_folder</code> 和 <code>marked</code> 配置，可以使用  <code>markdown</code> 风格语法的相对路径引用图片等资源。</p><h4 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a>配置如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><blockquote><p>参考官方文档<a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹</a>:</p></blockquote><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://hexo.io/zh-cn/docs/writing">写作指南</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844904131266609165#heading-18</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://b.mithril.cool/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Xcode中C++头文件的处理</title>
    <link href="http://b.mithril.cool/2015/02/06/about-xcode-include/"/>
    <id>http://b.mithril.cool/2015/02/06/about-xcode-include/</id>
    <published>2015-02-05T16:00:00.000Z</published>
    <updated>2020-10-16T12:40:14.397Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在C++方面一直比较生疏，今天想使用集成flatbuffers到自己的项目中去，由于cocos2d-x 3.3版本已经自带了flatbuffers，所以直接使用了cocos中flatbuffers得版本。<br><br>但是集成时，include “flatbuffers/flatbuffers.h”会出现找不到的问题。如果使用include “flatbuffers.h”就可以。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>通过研究cocos2d-x 3.0的XCode的工程组织方式，大概明白一些。<br><br>当我们组织include文件的时候，可能根据库的类型组织，比如flatbuffers放到Project/external/flattbuffers/。<br><br>这个时候如果直接添加external到工程中，默认创建了Group external之后，应用头文件就只能使用<br>“flatbuffers.h”的方式引用。<br><br>如果想使用”flatbuffers/flatbuffers.h”，就需要添加 $(SRCROOT)/external 到User Header Search Paths中去。<br><br>添加之后，我们#include的时候可以发现，两种方式的#include都可以使用。<br>#include “flatbuffers.h”<br>#include “flatbuffers/flatbuffers.h”<br><br><br>这里也可以看出，external的路径关联是可以去掉的。这样我们可以新建一个external组，但是不用和任何具体的路径关联，然后添加flatbuffers到external中去，然后添加User Header Search Paths即可。这样减少external目录修改产生的大量库文件需要重新添加的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;在C++方面一直比较生疏，今天想使用集成flatbuffers到自己的项目中去，由于cocos2d-x 3.3版本已经自带了</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java技术杂谈</title>
    <link href="http://b.mithril.cool/2015/02/05/about-java-technology/"/>
    <id>http://b.mithril.cool/2015/02/05/about-java-technology/</id>
    <published>2015-02-04T16:00:00.000Z</published>
    <updated>2020-10-16T12:40:14.397Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java技术的难点"><a href="#Java技术的难点" class="headerlink" title="Java技术的难点"></a>Java技术的难点</h4><p>Java技术通常的难点多线程，故障分析和解决，以及泛型，反射和注解的特性的应用。</p><h4 id="多线程技术"><a href="#多线程技术" class="headerlink" title="多线程技术"></a>多线程技术</h4><p>多线程中主要困难就是读写产生的并发问题。Java中有很多锁机制和并发的控制机制来保证写和读的同步问题。在早期的java多线程中主要理由Object中的monitor来实现synchronize,notify和wait等多线程控制机制，并且实现多个工具类。新版本的多线程控制中，引入了新的锁机制，极大的丰富的多线程的读写同步的问题并且提供了性能。对这方面知识，通读Java并发编程应该可以有很大提高。要想更加牢固的掌握并发知识，还需要通过对Linux系统中对CPU的锁操作，缓存机制有一定的掌握才可以。另外就是多线程的配合问题，多资源的生产者和多资源的消费者，并且资源消耗消耗又存在匹配规则的时候，就更为困难了。<br>如果能整理一个多线程的实例DEMO方便的演示，会极大的方便对多线程技术的理解。</p><h4 id="故障分析和解决"><a href="#故障分析和解决" class="headerlink" title="故障分析和解决"></a>故障分析和解决</h4><p>故障总是会发生，很多时候我们都是无从下手。原因是对工具和JVM实现机制不够了解导致的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Java技术的难点&quot;&gt;&lt;a href=&quot;#Java技术的难点&quot; class=&quot;headerlink&quot; title=&quot;Java技术的难点&quot;&gt;&lt;/a&gt;Java技术的难点&lt;/h4&gt;&lt;p&gt;Java技术通常的难点多线程，故障分析和解决，以及泛型，反射和注解的特性的应用。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一年之计在与春</title>
    <link href="http://b.mithril.cool/2015/02/04/a-start/"/>
    <id>http://b.mithril.cool/2015/02/04/a-start/</id>
    <published>2015-02-03T16:00:00.000Z</published>
    <updated>2020-10-16T12:40:14.397Z</updated>
    
    <content type="html"><![CDATA[<p>写在开始，许久之前写过技术博客，偶尔传授一下经验，转眼这些年，学习了很多东西，大部分都是有evernote记录了。之前不写博客的原因是缺少独立性，这些年总是想写些东西，但是搭建一个独立的博客有有点麻烦，缺乏耐心和时间。<br><br/><br>今天恰好是立春，一年之计在于春,总算可以用着小小的博客记录这偌大的世界，记录技术点滴，生活琐事，心情随笔，所得所思立于文字之上。</p><p>这开始便是美好，人生而立之年，望能更上一层楼。</p><p>– 不积跬步，无以至千里</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写在开始，许久之前写过技术博客，偶尔传授一下经验，转眼这些年，学习了很多东西，大部分都是有evernote记录了。之前不写博客的原因是缺少独立性，这些年总是想写些东西，但是搭建一个独立的博客有有点麻烦，缺乏耐心和时间。&lt;br&gt;&lt;br/&gt;&lt;br&gt;今天恰好是立春，一年之计在于春</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Android模拟器加速</title>
    <link href="http://b.mithril.cool/2015/02/04/speed-up-android-emulator/"/>
    <id>http://b.mithril.cool/2015/02/04/speed-up-android-emulator/</id>
    <published>2015-02-03T16:00:00.000Z</published>
    <updated>2020-10-16T12:40:14.397Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android模拟器加速"><a href="#Android模拟器加速" class="headerlink" title="Android模拟器加速"></a>Android模拟器加速</h4><p>最近在极客学院看到一篇教程，可以有效的提高安卓模拟器的速度。<br>只需要下载 <a href="https://software.intel.com/zh-cn/android">硬件加速执行管理器</a>，并新建AVD为x86架构的模拟器即可。<br><br/><br>实际的体验，速度确实提升很多，并且支持MAC和Windows系统。<br><br/><br>关于Android Studio的两个小问题</p><ol><li>国内很多人下载Android Studio之后首次启动都会停在获取SDK的界面。这个问题只需要添加<br> disable.android.first.run=true<br>这句到bin/idea.properties 即可。</li><li>启动Android Studio有可能点击不了创建Android工程。这主要是Android SDK的路径配置问题。点击Configure-&gt;Project Defaults-&gt;Project Structure 设置好Android SDK的路径即可解决。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Android模拟器加速&quot;&gt;&lt;a href=&quot;#Android模拟器加速&quot; class=&quot;headerlink&quot; title=&quot;Android模拟器加速&quot;&gt;&lt;/a&gt;Android模拟器加速&lt;/h4&gt;&lt;p&gt;最近在极客学院看到一篇教程，可以有效的提高安卓模拟器的速度。</summary>
      
    
    
    
    
    <category term="Tech" scheme="http://b.mithril.cool/tags/Tech/"/>
    
  </entry>
  
</feed>
