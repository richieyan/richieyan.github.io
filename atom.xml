<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>skald.top</title>
  
  
  <link href="https://skald.top/atom.xml" rel="self"/>
  
  <link href="https://skald.top/"/>
  <updated>2021-01-02T13:41:30.145Z</updated>
  <id>https://skald.top/</id>
  
  <author>
    <name>skald</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文搞懂云原生追踪遥测技术 OpenTelemetry</title>
    <link href="https://skald.top/2020/12/31/opentelemetry-intro/"/>
    <id>https://skald.top/2020/12/31/opentelemetry-intro/</id>
    <published>2020-12-31T13:24:11.000Z</published>
    <updated>2021-01-02T13:41:30.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遥测技术"><a href="#遥测技术" class="headerlink" title="遥测技术"></a>遥测技术</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当我们使软件系统成为分布式时，首先要做的事情之一就是观察和理解应用程序作为一个整体在做什么。</p><p>但是理解一个复杂的系统很困难，如果它是一个黑匣子。点燃这些黑匣子的唯一方法是使用高质量的遥测技术：分布式跟踪、度量、日志等等。</p><p>那么，我们如何才能从整个现代软件栈中获得精确、低开销的遥测数据呢？</p><p>一种方法是仔细地检测每一个微服务，一件一件，一层一层。这将是真正地工作，它也是完全不适合初学者 - 我们将花在测量上的时间和我们在软件本身上的时间一样多！</p><p>我们需要将遥测技术作为我们服务的一项内置功能。</p><h3 id="三大支柱"><a href="#三大支柱" class="headerlink" title="三大支柱"></a>三大支柱</h3><ul><li><p>Metrics：应用于服务拓扑，指标分析，监控报表，告警</p><p>Metrics 是一种聚合态的数据形式，日常中经常会接触到的 QPS、TP99、TP95 等等都属于Metrics 的范畴，它和统计学的关系最为密切，往往需要使用统计学的原理来做一些设计；</p></li><li><p>Tracing：应用于全链路跟踪数据，请求级别</p><p>Tracing 这个概念几乎是由 SOA 时代带来的复杂性补偿，服务化带来的长调用链，仅仅依靠日志是很难去定位问题的，因此它的表现形式比 Metrics 更复杂，好在业界涌现出来了多个协议以支撑 Tracing 维度的统一实现；</p></li><li><p>Logging：应用于服务拓扑，请求分析，链路回溯，告警源</p><p>Logging 是由请求或者事件触发，应用程序当中用以记录状态快照信息的一种形式，简单说就是日志，但这个日志不仅仅是打印出来这么简单，它的统一收集、存储以及解析都是一个有挑战的事情，比如结构化(Structured)与非结构化(Unstructed)的日志处理，往往需要一个高性能的解析器与缓冲器；</p></li></ul><h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p><img src="/2020/12/31/opentelemetry-intro/03.jpg" alt="3"></p><ul><li>Low volume 低存储量级</li><li>High volume 高存储量级</li></ul><h3 id="协议标准"><a href="#协议标准" class="headerlink" title="协议标准"></a>协议标准</h3><ul><li>OpenTracing 分布式跟踪 API，以 tracing 为主</li><li>OpenCensus 谷歌开源分布式追踪，用于处理 metric 和 trace 的标准通信协议和一致的 API</li><li>OpenTelemetry 云原生，合并 OpenTracing 与 OpenCensus</li></ul><h3 id="知名中间件"><a href="#知名中间件" class="headerlink" title="知名中间件"></a>知名中间件</h3><h4 id="tracing-追踪"><a href="#tracing-追踪" class="headerlink" title="tracing 追踪"></a>tracing 追踪</h4><ul><li>zipkin 老牌，2012</li><li>jaeger 新兴，云原生 lstio 2016</li><li>skywalking 新兴 2015，国人佳作</li></ul><h4 id="metrics-指标"><a href="#metrics-指标" class="headerlink" title="metrics 指标"></a>metrics 指标</h4><ul><li>statsd, graphite/Prometheus</li></ul><h4 id="logging-日志"><a href="#logging-日志" class="headerlink" title="logging 日志"></a>logging 日志</h4><ul><li>fluentd (k8s) / ELK(传统)</li><li>Envoy access log</li></ul><h2 id="OpenTelemetry-项目"><a href="#OpenTelemetry-项目" class="headerlink" title="OpenTelemetry 项目"></a>OpenTelemetry 项目</h2><p>OpenTelemetry 合并了 OpenTracing 和 OpenCensus 项目，提供了一组 API 和库来标准化遥测数据的采集和传输。OpenTelemetry 提供了一个安全，厂商中立的工具，这样就可以按照需要将数据发往不同的后端。</p><p>OpenTelemetry项目由如下组件构成：</p><ul><li>推动在所有项目中使用一致的规范</li><li>基于规范的，包含接口和实现的APIs</li><li>不同语言的SDK(APIs的实现)，如 Java, Python, Go, Erlang 等</li><li>Exporters：可以将数据发往一个选择的后端</li><li>Collectors：厂商中立的实现，用于处理和导出遥测数据</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li>Traces 记录经过分布式系统的请求活动，一个trace是spans的有向无环图</li><li>Spans 一个trace中表示一个命名的，基于时间的操作。Spans嵌套形成trace树。每个trace包含一个根span，描述了端到端的延迟，其子操作也可能拥有一个或多个子spans。</li><li>Metrics 在运行时捕获的关于服务的原始度量数据</li><li>Context 一个span包含一个span context，它是一个全局唯一的标识，表示每个span所属的唯一的请求，以及跨服务边界转移trace信息所需的数据</li><li>Context propagation 表示在不同的服务之间传递上下文信息，通常通过HTTP首部。 Context propagation 是 Opentelemetry 系统的关键功能之一除了tracing之外，还有一些有趣的用法，如，执行A/B测试，全链路测试标记</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>通过将 OpenTracing 和 OpenCensus 合并为一个开放的标准，OpenTelemetry 提供了如下便利：</p><ul><li><p>选择简单：不必在两个标准之间进行选择，OpenTelemetry 可以同时兼容 OpenTracing 和OpenCensus。</p></li><li><p>跨平台：OpenTelemetry 支持各种语言和后端。它代表了一种厂商中立的方式，可以在不改变现有工具的情况下捕获并将遥测数据传输到后端。</p></li><li><p>简化可观测性：正如 OpenTelemetry 所说的”高质量的观测下要求高质量的遥测”。希望看到更多的厂商转向 OpenTelemetry，因为它更方便，且仅需测试单一标准。</p></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>OpenTelemetry 的默认实现中，其架构可以分为如下三部分</p><ul><li>OpenTelemetry API</li><li>OpenTelemetry SDK</li><li>Collector</li></ul><p><strong>架构图</strong></p><p><img src="/2020/12/31/opentelemetry-intro/architech.png" alt="架构图"></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li>语义规范 该规范包含了命名 spans，属性以及与 spans 相关的错误</li><li>A Tracer API 生成spans，可以给 span 分配一个 traceId,也可以选择性地加上时间戳</li><li>A Metrics API 提供了多种类型的 Metric instruments(桩功能)，如 Counters 和 Observers。Counters 允许对度量进行计算，Observers 允许获取离散时间点上的测量值。</li><li>A Context API 会在使用相同 “context” 的 spans 和 traces 中添加上下文信息如 W3C Trace Context, Zipkin B3 首部, 或 New Relic distributed tracing 首部</li></ul><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><blockquote><p>OpenTelemetry SDK 是 OpenTelemetry API 的实现</p></blockquote><ul><li>Tracer pipeline</li></ul><p>当配置 SDK 时，需要将一个或多个 SpanProcessors 与 Tracer pipeline 的实现进行关联。SpanProcessors 会查看 spans 的生命周期，然后在合适的时机将spans传送到一个 SpanExporter。SDK中内置了一个简单的 SpanProcessor，可以将完成的 spans 直接转发给 exporter。</p><p>Tracer pipeline 的最后是 SpanExporter。一个 exporter 的工作很简单：将 OpenTelemetry 的spans 转换为遥测后端要求的表达格式，然后转发给该后端即可。提供定制化的SpanExporter是遥测厂商参与 OpenTelemetry 生态系统的最简单方式。</p><ul><li>Meter pipeline</li></ul><p>Meter pipeline 会创建和维护多种类型的 metric 工具，包括 Counters 和 Observers。每个工具的实例都需要以某种方式聚合</p><p>默认情况下，Counters 通过累加数值进行聚合，而 Observers 通过采集记录到的最后一个数值进行聚合。所有的工具默认都有一个聚合</p><p>不同语言的 Meter pipeline 的实现会有所不同，但所有场景下，metric 的聚合结果都会被传递到MetricExporter。与 spans 类似，供应商可以提供自己的 exporter，将由 metric aggregators生成的聚合数据转换为遥测后端所需的类型</p><p>OpenTelemetry 支持两种类型的 exporter：基于 exporters 的”push”，即 exporter 按照时间间隔将数据发送到后端；基于 exporters 的”pull”，即后端按照需要请求数据。New Relic 是一个基于push的后端，而 Prometheus 是一个基于 push 的后端。</p><ul><li>Shared Context Layer</li></ul><p>位于 Tracer 和 Meter pipeline 之间，允许在一个执行的 span 的上下文中记录所有非observer的metric。可以使用 propagators 自定义Context，在系统内外传递 span 上下文。OpenTelemetry SDK 提供了一个基于 W3C Trace Context 规范的实现，但也可以根据需要来包含 Zipkin B3 propagation 等。</p><h3 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h3><p>OpenTelemetry Collector 提供了一种厂商中立的实现，无缝地接收，处理和导出遥测数据。此外，它移除了为支持发送到多个开源或商业后端而使用的开源可观察性数据格式(如 Jaeger，Prometheus 等)的运行，操作和维护。</p><p>OpenTelemetry collector可以扩展或嵌入其他应用中。下面应用扩展了collector：</p><ul><li>opentelemetry-collector-contrib</li><li>jaeger</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1638897">从Service Mesh谈如何做好监控</a></li><li><a href="https://cloud.tencent.com/developer/article/1735988">OpenTelemetry 架构介绍</a></li><li><a href="https://cloud.tencent.com/developer/article/1735989">OpenTelemetry Metrics API</a></li><li><a href="https://cloud.tencent.com/developer/article/1735991">OpenTelemetry Metrics SDK</a></li><li><a href="https://cloud.tencent.com/developer/article/1722291">实现全托管，腾讯云服务网格的架构演进</a></li><li><a href="https://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html">Metrics, tracing, and logging - Peter Bourgon</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;遥测技术&quot;&gt;&lt;a href=&quot;#遥测技术&quot; class=&quot;headerlink&quot; title=&quot;遥测技术&quot;&gt;&lt;/a&gt;遥测技术&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h</summary>
      
    
    
    
    
    <category term="Java" scheme="https://skald.top/tags/Java/"/>
    
    <category term="Cloud Native" scheme="https://skald.top/tags/Cloud-Native/"/>
    
    <category term="OpenTelemetry" scheme="https://skald.top/tags/OpenTelemetry/"/>
    
  </entry>
  
  <entry>
    <title>快速上手高性能 RPC 框架 gRPC</title>
    <link href="https://skald.top/2020/10/21/grpc-nutshell-in-java/"/>
    <id>https://skald.top/2020/10/21/grpc-nutshell-in-java/</id>
    <published>2020-10-21T04:21:03.000Z</published>
    <updated>2020-10-21T10:31:46.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gRPC-简介"><a href="#gRPC-简介" class="headerlink" title="gRPC 简介"></a>gRPC 简介</h2><p>gRPC是由Google开发并高性能的开源，基于http2和protobuf 序列化的 RPC 框架, 它具有以下特点</p><ul><li>语言中立<br>支持C,Java,Go等多种语言来构建RPC服务,这是gRPC被广泛的应用在微服务项目中的重要原因,因为不同的微服务可能用不同的语言构建。</li><li>基于HTTP/2协议<br>支持双向流,消息头压缩,单TCP的多路复用,服务端推送等,这些特性使得gRPC更加适用于移动场景下的客户端和服务端之间的通信。</li><li>基于 IDL 定义服务<br>编写.proto文件即可生成特定语言的数据结构、服务端接口和客户端Stub。</li><li>支持Protocol Buffer序列化<br>Protocol Buffer是由Google开发的一种数据序列化协议(类似于XML、JSON、Hession),平台无关,压缩和传输效率高,语法简单,表达能力强。</li></ul><p><strong>gRPC服务的大体架构</strong></p><p><img src="/2020/10/21/grpc-nutshell-in-java/grpc-intro.svg" alt="gRPC Overview"></p><h2 id="协议定义"><a href="#协议定义" class="headerlink" title="协议定义"></a>协议定义</h2><p>gRPC 中使用 protocol buffers 做接口定义语言(IDL)，同时也作为默认的消息交换格式，在设计上，gRPC 是可以支持 JSON 等其他消息格式的。</p><p>一个典型的协议<code>proto</code>定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">option java_package &#x3D; &quot;com.example.grpc&quot;;</span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line">option java_outer_classname &#x3D; &quot;HelloWorldProto&quot;;</span><br><span class="line">message Greeting &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloResp &#123;</span><br><span class="line">    string reply &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service HelloWorld &#123;</span><br><span class="line">    rpc sayHello (Greeting) returns (HelloResp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>java_package</code>表示生成<code>java</code>代码的包名</li><li><code>java_multiple_files = true</code> 表示生成多个java文件，若不设置该属性，则只会生成一个java文件</li><li><code>java_outer_classname</code>表示包含message描述的java文件的类名</li><li><code>message</code>用于定义消息格式，是 <code>protocol buffers</code> 消息定义</li><li><code>service</code> 用于定义<code>gRPC</code>服务接口，需要使用插件的方式生成对应的服务代码</li></ul><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.30.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.30.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.30.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.30.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加-maven-插件"><a href="#添加-maven-插件" class="headerlink" title="添加 maven 插件"></a>添加 maven 插件</h2><p>插件的主要作用是把 <code>.proto</code> 文件转换为 Java 代码。</p><blockquote><p>编译默认的输出位置在打包目录的<code>generated-sources/protobuf/</code>文件夹下，可参考插件<a href="https://www.xolstice.org/protobuf-maven-plugin/">官方文档</a></p></blockquote><p>gRPC 利用<code>proto</code>文件定义了消息交互格式以及服务，插件配置中<code>goals</code>中<code>compile</code>表示编译<code>proto</code>文件为<code>Message</code>对象，即消息交互格式，而<code>compile-custom</code>表示编译<code>.proto</code>文件为<code>gRPC</code>服务对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.12.0:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.30.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>maven</code>的配置文件下添加如下配置, 将<code>Message</code>源文件和<code>gRPC</code>源文件输出到不同的目录：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Message Java 代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">javaOutputDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java-proto<span class="tag">&lt;/<span class="name">javaOutputDirectory</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- gRPC 服务 Java 代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">protocPluginOutputDirectory</span>&gt;</span></span><br><span class="line">    $&#123;project.basedir&#125;/src/main/java-grpc</span><br><span class="line">  <span class="tag">&lt;/<span class="name">protocPluginOutputDirectory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的一点是，gRPC 服务代码依赖<code>Message</code>代码。</p><p>运行下面的命令，即可生成代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean complie</span><br></pre></td></tr></table></figure><p>可以看到生成的代码如下：</p><p><img src="/2020/10/21/grpc-nutshell-in-java/gen-source-1.png" alt="source code"></p><h2 id="服务端代码实现"><a href="#服务端代码实现" class="headerlink" title="服务端代码实现"></a>服务端代码实现</h2><h3 id="1-实现服务端接口"><a href="#1-实现服务端接口" class="headerlink" title="1. 实现服务端接口"></a>1. 实现服务端接口</h3><p><code>HelloWorldImplBase</code> 与 <code>Thrift</code> 中 <code>Iface</code> 类似, gRPC 通过扩展这个类，来实现响应的服务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldRpcService</span> <span class="keyword">extends</span> <span class="title">HelloWorldGrpc</span>.<span class="title">HelloWorldImplBase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Greeting request, StreamObserver&lt;HelloResp&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求的数据</span></span><br><span class="line">        String name = request.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造响应</span></span><br><span class="line">        HelloResp resp = HelloResp.newBuilder()</span><br><span class="line">                .setReply(<span class="string">&quot;Hello &quot;</span> + name)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// onNext 设置响应</span></span><br><span class="line">        responseObserver.onNext(resp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常完成</span></span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建服务端"><a href="#2-创建服务端" class="headerlink" title="2. 创建服务端"></a>2. 创建服务端</h3><p>我们使用 <code>gRPC</code> 默认的服务来启动即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 服务端占用的端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GrpcServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                <span class="comment">// 将具体实现的服务添加到 gRPC 服务中</span></span><br><span class="line">                .addService(<span class="keyword">new</span> HelloWorldRpcService())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitTermination</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-服务主程序"><a href="#3-服务主程序" class="headerlink" title="3. 服务主程序"></a>3. 服务主程序</h3><p>设置好端口，启动后，等待服务结束信号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        GrpcServer server = <span class="keyword">new</span> GrpcServer(<span class="number">8888</span>);</span><br><span class="line">        server.start();</span><br><span class="line">        server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>server.awaitTermination()</code> 调用后才能保证主进程不会退出</li></ul><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><h3 id="1-创建客户端-Stub-对象"><a href="#1-创建客户端-Stub-对象" class="headerlink" title="1. 创建客户端 Stub 对象"></a>1. 创建客户端 <code>Stub</code> 对象</h3><p><code>gRPC</code>通过<code>Stub</code>对象与服务端通信，本例需要创建 <code>HelloWorldBlockingStub</code>， 来实现客户端与服务端通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HelloWorldGrpc.HelloWorldBlockingStub blockingStub;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ManagedChannel managedChannel = ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">                <span class="comment">// 使用非安全机制传输</span></span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        blockingStub = HelloWorldGrpc.newBlockingStub(managedChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Greeting greeting = Greeting.newBuilder()</span><br><span class="line">                .setName(name)</span><br><span class="line">                .build();</span><br><span class="line">        HelloResp resp = blockingStub.sayHello(greeting);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resp.getReply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-客户端主程序"><a href="#2-客户端主程序" class="headerlink" title="2. 客户端主程序"></a>2. 客户端主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        String reply = client.sayHello(<span class="string">&quot;HanMeiMei&quot;</span>);</span><br><span class="line">        System.out.println(reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用命令行的方式生成代码"><a href="#使用命令行的方式生成代码" class="headerlink" title="使用命令行的方式生成代码"></a>使用命令行的方式生成代码</h2><p>使用命令行的方式可以批量处理或自定义协议管理器，从而提升对协议维护管理效率。</p><h3 id="1-下载编译好的-protoc-二进制文件"><a href="#1-下载编译好的-protoc-二进制文件" class="headerlink" title="1. 下载编译好的 protoc 二进制文件"></a>1. 下载编译好的 protoc 二进制文件</h3><p>在 gRPC <a href="https://github.com/protocolbuffers/protobuf/releases">Github 发布页</a>，下载系统对应的二进制版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-osx-x86_64.zip</span><br></pre></td></tr></table></figure><p>解压到 ~/protoc-3.13.0-osx-x86_64</p><h3 id="2-下载编译好的-protoc-java-gen-插件"><a href="#2-下载编译好的-protoc-java-gen-插件" class="headerlink" title="2. 下载编译好的 protoc-java-gen 插件"></a>2. 下载编译好的 protoc-java-gen 插件</h3><p>在 maven repo <a href="https://repo1.maven.org/maven2/io/grpc/protoc-gen-grpc-java/1.32.2/">发布目录</a>下 找到对应平台的文件下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo1.maven.org/maven2/io/grpc/protoc-gen-grpc-java/1.32.2/protoc-gen-grpc-java-1.32.2-osx-x86_64.exe</span><br></pre></td></tr></table></figure><p>把此文件放到 ~/protoc-3.13.0-osx-x86_64/plugin 目录下</p><h3 id="3-命令行"><a href="#3-命令行" class="headerlink" title="3. 命令行"></a>3. 命令行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># protoc 根路径</span></span><br><span class="line">PROTOC_ROOT=/usr/<span class="built_in">local</span>/protoc-3.13.0-osx-x86_64</span><br><span class="line"><span class="comment"># java plugin 路径</span></span><br><span class="line">PROTOC_PLUGIN_JAVA=<span class="string">&quot;protoc-gen-grpc-java=<span class="variable">$PROTOC_ROOT</span>/plugin/protoc-gen-grpc-java-1.32.2-osx-x86_64.exe&quot;</span></span><br><span class="line"><span class="comment"># proto 协议目录</span></span><br><span class="line">SRC_PROTO_DIR=<span class="string">&quot;proto/&quot;</span></span><br><span class="line"><span class="comment"># 生成代码的 Java 协议目录</span></span><br><span class="line">DST_JAVA_DIR=<span class="string">&quot;gen-java-proto&quot;</span> </span><br><span class="line"><span class="comment"># 生成代码的 GRPC 服务目录</span></span><br><span class="line">DST_GRPC_DIR=<span class="string">&quot;gen-java-grpc&quot;</span></span><br><span class="line"><span class="comment"># 主协议文件</span></span><br><span class="line">MAIN_PROTO_FILE=<span class="string">&quot;proto/HelloService.proto&quot;</span></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">protoc --plugin=<span class="variable">$PROTOC_PLUGIN_JAVA</span> -I=<span class="variable">$SRC_PROTO_DIR</span> --java_out=<span class="string">&quot;gen-java-proto&quot;</span> \</span><br><span class="line"> --grpc-java_out=<span class="string">&quot;gen-java-proto&quot;</span> <span class="string">&quot;proto/HelloService.proto&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;gRPC-简介&quot;&gt;&lt;a href=&quot;#gRPC-简介&quot; class=&quot;headerlink&quot; title=&quot;gRPC 简介&quot;&gt;&lt;/a&gt;gRPC 简介&lt;/h2&gt;&lt;p&gt;gRPC是由Google开发并高性能的开源，基于http2和protobuf 序列化的 RPC 框架</summary>
      
    
    
    
    
    <category term="Java" scheme="https://skald.top/tags/Java/"/>
    
    <category term="grpc" scheme="https://skald.top/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>Java 性能分析之 Arthas 火焰图</title>
    <link href="https://skald.top/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    <id>https://skald.top/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/</id>
    <published>2020-10-16T13:01:37.000Z</published>
    <updated>2020-10-21T06:15:35.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要做性能分析"><a href="#为什么要做性能分析" class="headerlink" title="为什么要做性能分析"></a>为什么要做性能分析</h2><p>很多场景的 Java 应用中 IT 成本中 CPU 成本常常是成本的大头，如果能够有效优化 Java 应用的 CPU 占用，可以较好降低成本，提升程序响应速度。<br>Java 性能分析分为两部分</p><ul><li><strong>业务性能：某些的业务代码引起的性能瓶颈</strong></li><li>JVM 性能调优：JVM 设置存在优化</li></ul><p>本文主要关注业务代码的热点问题。</p><h2 id="Arthas-是什么？"><a href="#Arthas-是什么？" class="headerlink" title="Arthas 是什么？"></a>Arthas 是什么？</h2><blockquote><p><em>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</em></p></blockquote><blockquote><p><a href="https://arthas.aliyun.com/doc/">官方文档</a>  <a href="https://github.com/alibaba/arthas">源码地址</a></p></blockquote><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li><strong>怎么快速定位应用的热点，生成火焰图？</strong></li></ul><p>本文主要介绍如何利用 <code>profiler</code> 命令来定位应用热点，从而优化应用的性能。</p><h2 id="为什么选择-Arthas-来做火焰图？"><a href="#为什么选择-Arthas-来做火焰图？" class="headerlink" title="为什么选择 Arthas 来做火焰图？"></a>为什么选择 Arthas 来做火焰图？</h2><p>Arthas 无需代理模式启动应用，通过 Attach 进程方式即可实现 Java 应用的诊断与性能分析。<br>详细可以参考：<a href="https://zhuanlan.zhihu.com/p/115127052">Arthas 原理分析</a></p><p>Java 火焰图在 Netflix 的加持下，逐渐成熟， <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profile</a> 出现后进一步降低了对 Java 火焰图的分析步骤。</p><p>Arthas 在 3.1.5 版本开始支持 <code>async-profile</code>, 无需配置，快速实现 profile 分析。</p><h2 id="使用-Arthas-生成火焰图"><a href="#使用-Arthas-生成火焰图" class="headerlink" title="使用 Arthas 生成火焰图"></a>使用 Arthas 生成火焰图</h2><h3 id="安装和启动-Arthas"><a href="#安装和启动-Arthas" class="headerlink" title="安装和启动 Arthas"></a>安装和启动 Arthas</h3><p>全量安装<br><code>arthas</code> 是一个 <code>jar</code> 包，下载后直接运行即可，然后执行相应命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir arthas; <span class="built_in">cd</span> arthas;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全量安装</span></span><br><span class="line">wget https://arthas.aliyun.com/download/latest_version?mirror=aliyun -O arthas.zip</span><br><span class="line">unzip arthas.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非全量安装</span></span><br><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><h3 id="创建火焰图"><a href="#创建火焰图" class="headerlink" title="创建火焰图"></a>创建火焰图</h3><h4 id="启动-arthas-后，attach-到实际的进程"><a href="#启动-arthas-后，attach-到实际的进程" class="headerlink" title="启动 arthas 后，attach 到实际的进程"></a>启动 arthas 后，attach 到实际的进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  arthas java -jar arthas-boot.jar</span><br><span class="line">[INFO] arthas-boot version: 3.4.3</span><br><span class="line">[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.</span><br><span class="line">*  [1]: 4541</span><br><span class="line">1</span><br><span class="line">[INFO] arthas home: /Users/yzz/.arthas/lib/3.4.3/arthas</span><br><span class="line">[INFO] Try to attach process 4541</span><br><span class="line">[INFO] Attach process 4541 success.</span><br><span class="line">[INFO] arthas-client connect 127.0.0.1 3658</span><br><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.</span><br><span class="line"> /  O  \ |  .--. <span class="string">&#x27;&#x27;</span>--.  .--<span class="string">&#x27;|  &#x27;</span>--<span class="string">&#x27;  | /  O  \ &#x27;</span>   .-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">|  .-.  ||  &#x27;</span>--<span class="string">&#x27;.&#x27;</span>   |  |   |  .--.  ||  .-.  |`.  `-.</span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">`--&#x27;</span> `--<span class="string">&#x27;`--&#x27;</span> <span class="string">&#x27;--&#x27;</span>   `--<span class="string">&#x27;   `--&#x27;</span>  `--<span class="string">&#x27;`--&#x27;</span> `--<span class="string">&#x27;`-----&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wiki      https://arthas.aliyun.com/doc</span><br><span class="line">tutorials https://arthas.aliyun.com/doc/arthas-tutorials.html</span><br><span class="line">version   3.4.3</span><br><span class="line">pid       4541</span><br><span class="line">time      2020-10-17 13:14:03</span><br><span class="line"></span><br><span class="line">[arthas@4541]$</span><br></pre></td></tr></table></figure><p><em>注意： 输入前面的序号 <code>1</code> 不是 <code>724</code></em></p><h4 id="使用-profiler-命令"><a href="#使用-profiler-命令" class="headerlink" title="使用 profiler 命令"></a>使用 <code>profiler</code> 命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">[arthas@4541]$ profiler start</span><br><span class="line">Started [cpu] profiling</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">[arthas@4541]$ profiler status</span><br><span class="line">[cpu] profiling is running <span class="keyword">for</span> 13 seconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">[arthas@4541]$ profiler stop --file /tmp/output.svg</span><br><span class="line">OK</span><br><span class="line">profiler output file: /tmp/output.svg</span><br></pre></td></tr></table></figure><p>本机可以通过 <code>http://localhost:3658/arthas-output/</code> 直接查看结果<br>也可以通过 <code>Chrome</code> 打开 <code>output.svg</code> 文件</p><p><img src="/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/flame-1.jpg" alt="Flame-1"></p><p>点击某个函数调用栈可以看到放大局部的调用栈，最新 <code>3.28%</code> 是 CPU 占比。<br><img src="/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/flame-2.jpg" alt="Flame-2"></p><p>点击 <code>all</code> 返回默认的全局展示。</p><h4 id="容器内使用"><a href="#容器内使用" class="headerlink" title="容器内使用"></a>容器内使用</h4><p>由于 <code>k8s</code> 的 <code>perf_event_open</code> 默认是未开启的状态，在容器内使用会有权限问题。</p><p>观察日志会发现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perf_event_open failed: Permission denied</span><br></pre></td></tr></table></figure><p>此时可以使用 <code>itimer</code> 事件来采样，此事件与 <code>cpu</code> 采样类似，但是不需要 <code>perf_events</code> 支持，缺点是无法统计内核的堆栈性能。通过 <code>--event</code> 可以指定</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 itimer 采样</span></span><br><span class="line">[arthas@4541]$ profiler start --event itimer</span><br><span class="line">Started [cpu] profiling</span><br></pre></td></tr></table></figure><blockquote><p>其他问题可以参考：<a href="https://github.com/jvm-profiling-tools/async-profiler#troubleshooting">async-profiler#troubleshooting</a></p></blockquote><h2 id="看懂火焰图"><a href="#看懂火焰图" class="headerlink" title="看懂火焰图"></a>看懂火焰图</h2><p><img src="/2020/10/16/Java-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8Barthas%E7%81%AB%E7%84%B0%E5%9B%BE/flame-grahs-how-to-read.webp" alt="Flame Graphs: How to Read"></p><p>Y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>X 轴表示抽样数，如果一个函数在x轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有平顶 (plateaus)，就表示该函数可能存在性能问题。</p><p>颜色没有实际意义，只是随机选取用于栈帧之间相互区分，左右顺序也没有什么含义。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要做性能分析&quot;&gt;&lt;a href=&quot;#为什么要做性能分析&quot; class=&quot;headerlink&quot; title=&quot;为什么要做性能分析&quot;&gt;&lt;/a&gt;为什么要做性能分析&lt;/h2&gt;&lt;p&gt;很多场景的 Java 应用中 IT 成本中 CPU 成本常常是成本的大头，如果能够有</summary>
      
    
    
    
    
    <category term="Java" scheme="https://skald.top/tags/Java/"/>
    
    <category term="Performance" scheme="https://skald.top/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>本站 Hexo 搭建历程</title>
    <link href="https://skald.top/2020/10/09/%E6%9C%AC%E7%AB%99-Hexo-%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"/>
    <id>https://skald.top/2020/10/09/%E6%9C%AC%E7%AB%99-Hexo-%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</id>
    <published>2020-10-09T03:56:34.000Z</published>
    <updated>2020-10-21T07:42:09.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.im/post/6844904131266609165#heading-18">使用Hexo+GitHubPages搭建个人博客</a></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库分为两个</p><ul><li>github pages 仓库： 用于托管博客</li><li>hexo blog 仓库： 用于管理博客</li></ul><h3 id="环境与插件"><a href="#环境与插件" class="headerlink" title="环境与插件"></a>环境与插件</h3><p>hexo blog 目录下安装 hexo 及插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置使用 taobo 源</span></span><br><span class="line">npm --registry https://registry.npm.taobao.org install</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo-cli</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># plugins</span></span><br><span class="line">npm i hexo-deployer-git --save</span><br><span class="line">npm i hexo-generator-json-content --save</span><br><span class="line">npm i hexo-wordcount --save</span><br><span class="line">npm i hexo-generator-feed --save</span><br><span class="line">npm i hexo-generator-sitemap --save</span><br><span class="line">npm i hexo-generator-baidu-sitemap --save</span><br><span class="line">npm i hexo-renderer-marked --save</span><br><span class="line">npm i hexo-asset-image --save</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>hexo 常用的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文章</span></span><br><span class="line">hexo new &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成博客</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预览博客</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布博客</span></span><br><span class="line">hexo generate --deploy</span><br><span class="line">hexo deploy --generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布博客简化版</span></span><br><span class="line">hexo g -d</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul><li>在 DNS 设置 <code>CNAME</code></li><li>在 <code>source</code> 创建一个 <code>CNAME</code> 文件, 本站内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skald.top</span><br></pre></td></tr></table></figure></li></ul><h3 id="文章资源"><a href="#文章资源" class="headerlink" title="文章资源"></a>文章资源</h3><p>通过 <code>post_asset_folder</code> 和 <code>marked</code> 配置，可以使用  <code>markdown</code> 风格语法的相对路径引用图片等资源。</p><h4 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a>配置如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><blockquote><p>参考官方文档<a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹</a>:</p></blockquote><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://hexo.io/zh-cn/docs/writing">写作指南</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844904131266609165#heading-18</summary>
      
    
    
    
    
    <category term="Hexo" scheme="https://skald.top/tags/Hexo/"/>
    
  </entry>
  
</feed>
